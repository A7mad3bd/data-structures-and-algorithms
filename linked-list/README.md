# Challenge Summary
Write a function kthFromEnd to get a value of node if it exist from the end of the linked list

## Whiteboard Process

<img alt="Whiteboard" height="300" src="/111.jpg" width="500"/>
## Approach & Efficiency

An approach is based on the kth index and when counter equals kth node it is complete.  The Big O for time O(n) counting up linear and the space is O(n) due to the recursive method.

## Solution

![](2222.jpg)
# Challenge Summary
This challenge has three functions for linked list:

append: Adds a new node with value at the end of the list.

Insert before: Add new node with value before specific node .

Insert after: Add new node with value after specific node .

## Whiteboard Process

<img alt="Add to the end" height="300" src="/assets/append.jpg" width="600"/>
=======
<img alt="append" height="300" src="/assets/append.jpg" width="600"/>


<img alt="Add before" height="300" src="/assets/add_before.jpg" width="500"/>

<img alt="Add after" height="300" src="/assets/add_after.jpg" width="500"/>

## Approach & Efficiency

all of them at the worst case will be O(n)
and maybe will be just O(1)

## Solution

<img alt="Code" height="300" src="/assets/123.jpg" width="400"/>







# Singly Linked List
It's a list Like arrays, but Linked List is a linear data structure. Unlike arrays,
linked list elements are not stored at a contiguous location,
the elements are linked using pointers.
## Challenge
The challenge asked to create a linked list and create 3 methods to insert nodes and check the value if includes in the list and another method called toString to print list in a special template
## Approach & Efficiency
The time complexity for the 3 methods is O(n) space O(1)     (linear)

## API
<!-- Description of each method publicly available to your Linked List -->
insert ->to insert nodes at first of the list
includes -> to check the value if includes in the list 
toString -> to print list in special template

